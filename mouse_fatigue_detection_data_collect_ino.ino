       /////////////////////////////////////////////
      // Mouse Fatigue Estimation by GSR and EMG //
     //          Values w/ TensorFlow           //
    //             ---------------             //
   //              (Wio Terminal)             //
  //             by Kutluhan Aktar           //
 //                                         //
/////////////////////////////////////////////

//
// Collate forearm muscle soreness data on the SD card, build and train a neural network model, and run the model directly on Wio Terminal.
//
// For more information:
// https://www.theamplituhedron.com/projects/Mouse_Fatigue_Estimation_by_GSR_and_EMG_Values_w_TensorFlow/
//
//
// Connections
// Wio Terminal :
//                                Grove - GSR sensor
// A0  --------------------------- Grove Connector
//                                Grove - EMG Detector
// A2  --------------------------- Grove Connector


// Include the required libraries.
#include <SPI.h>
#include <Seeed_FS.h>
#include "TFT_eSPI.h"
#include "seeed_line_chart.h"
#include "SD/Seeed_SD.h"
#include "RawImage.h"

// Define the TFT screen:
TFT_eSPI tft;

// Define the sprite settings: 
#define max_size 50 // maximum size of data
doubles gsr_data, emg_data;
TFT_eSprite spr = TFT_eSprite(&tft);

// Initialize the File class and define the file name: 
File myFile;
const char* data_file = "mouse_fatigue_data_set.csv";

// Define the sensor voltage (signal) pins:
#define GSR A0
#define EMG A2

// Define the data holders.
int gsr_value, emg_value;
uint32_t background_color = tft.color565(31,32,32);
uint32_t text_color = tft.color565(174,255,205);

void setup(){
  Serial.begin(115200);

  // Configurable Buttons:
  pinMode(WIO_KEY_A, INPUT_PULLUP);
  pinMode(WIO_KEY_B, INPUT_PULLUP);
  pinMode(WIO_KEY_C, INPUT_PULLUP);
  
  // Check the connection status between Wio Terminal and the SD card.
  if(!SD.begin(SDCARD_SS_PIN, SDCARD_SPI)) while (1);

  // Initiate the TFT screen:
  tft.begin();
  tft.setRotation(3);
  tft.fillScreen(background_color);
  tft.setTextColor(text_color);
  tft.setTextSize(2);
  // Create the sprite.
  spr.createSprite(TFT_HEIGHT / 2, TFT_WIDTH);

  // Define and display the 16-bit images saved on the SD card:
  drawImage<uint16_t>("data_collect.bmp", TFT_HEIGHT, 0);
  drawImage<uint16_t>("carpal_tunnel.bmp", TFT_HEIGHT/2, 0);
  drawImage<uint16_t>("mouse.bmp", TFT_HEIGHT/2, TFT_WIDTH-90);
}

void loop(){
  // Obtain current measurements generated by the GSR sensor and the EMG sensor.
  get_GSR_data(3);
  get_EMG_data();
  // Initialize the sprite.
  spr.fillSprite(background_color);
  
  // Adjust the line chart data arrays:
  if(gsr_data.size() == max_size) gsr_data.pop();
  if(emg_data.size() == max_size) emg_data.pop();
  
  // Append new data variables to the line chart data arrays:
  gsr_data.push(gsr_value);
  emg_data.push(emg_value);
  
  // Display the line charts on the TFT screen: 
  display_line_chart(0, "GSR", TFT_HEIGHT/2, 90, gsr_data, text_color, tft.color565(165,40,44));
  display_line_chart(110, "EMG", TFT_HEIGHT/2, 90, emg_data, text_color, tft.color565(165,40,44));
  spr.pushSprite(0, 0);
  spr.setTextColor(text_color);
  delay(50);

  // Save the data record to the given CSV file with the selected soreness class.
  if(digitalRead(WIO_KEY_A) == LOW) save_data_to_SD_Card("0");
  if(digitalRead(WIO_KEY_B) == LOW) save_data_to_SD_Card("1");
  if(digitalRead(WIO_KEY_C) == LOW) save_data_to_SD_Card("2");
}


void save_data_to_SD_Card(String Soreness){
  // Open the given CSV file on the SD card in the APPEND file mode.
  // FILE MODES: WRITE, READ, APPEND
  myFile = SD.open(data_file, FILE_APPEND);
  // If the given file is opened successfully:
  if(myFile){
    Serial.print("Writing to "); Serial.print(data_file); Serial.println("...");
    // Create the data record to be inserted as a new row: 
    String data_record = String(gsr_value) + "," + String(emg_value) + "," + Soreness;
    // Append the data record:
    myFile.println(data_record);
    // Close the CSV file:
    myFile.close();
    Serial.println("Data saved successfully!\n");
    // Notify the user after appending the given data record successfully.
    tft.fillScreen(background_color);
    drawImage<uint16_t>("data_collect.bmp", TFT_HEIGHT/4, 0);
    tft.drawString("Selected Soreness Class: " + Soreness, 0, 140);
    tft.drawString("Data Stored!", 86, 180);
  }else{
    // If Wio Terminal cannot open the given CSV file successfully:
    Serial.println("Wio Terminal cannot open the given CSV file!\n");
    tft.fillScreen(background_color);
    tft.drawString("Wio Terminal", 35, 105);
    tft.drawString("cannot open the file!", 35, 125);
  }
  // Exit and clear:
  delay(3000);
  tft.fillScreen(background_color);
  drawImage<uint16_t>("carpal_tunnel.bmp", TFT_HEIGHT/2, 0);
  drawImage<uint16_t>("mouse.bmp", TFT_HEIGHT/2, TFT_WIDTH-90);
}

void display_line_chart(int header_y, const char* header_title, int chart_width, int chart_height, doubles data, uint32_t graph_color, uint32_t line_color){
  // Define the line graph title settings:
  auto header =  text(0, header_y)
                 .value(header_title)
                 .align(center)
                 .valign(vcenter)
                 .width(chart_width)
                 .color(tft.color565(243,208,296))
                 .thickness(2);
  // Define the header height and draw the line graph title. 
  header.height(header.font_height() * 2);
  header.draw();
  // Define the line chart settings:
  auto content = line_chart(0, header.height() + header_y);
  content
  .height(chart_height) // the actual height of the line chart
  .width(chart_width) // the actual width of the line chart
  .based_on(0.0) // the starting point of the y-axis must be float
  .show_circle(false) // drawing a circle at each point, default is on
  .value(data) // passing the given data array to the line graph
  .color(line_color) // setting the line color 
  .x_role_color(graph_color) // setting the line graph color
  .x_tick_color(graph_color)
  .y_role_color(graph_color)
  .y_tick_color(graph_color)
  .draw();
}

void get_GSR_data(int calibration){
  long sum = 0;
  // Calculate the average of the last ten GSR sensor measurements to remove the glitch.
  for(int i=0;i<10;i++){
    sum += analogRead(GSR);
    delay(5);
  }
  gsr_value = (sum / 10) - calibration;
  Serial.print("GSR Value => "); Serial.println(gsr_value);
}

void get_EMG_data(){
  long sum = 0;
  // Evaluate the summation of the last 32 EMG sensor measurements.
  for(int i=0;i<32;i++){
    sum += analogRead(EMG);
  }
  // Shift the summation by five with the right shift operator (>>) to obtain the EMG value.  
  emg_value = sum >> 5;
  Serial.print("EMG Value => "); Serial.println(emg_value); Serial.println();
  delay(10);
}
